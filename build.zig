const std = @import("std");

pub fn build(b: *std.Build) !void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{
        .preferred_optimize_mode = .ReleaseSafe,
    });

    const frontend_path = try generate_frontend(b);

    const lib_webview = b.dependency("webview", .{});

    const webview = b.addTranslateC(.{
        .root_source_file = lib_webview.path("core/include/webview/webview.h"),
        .optimize = optimize,
        .target = target,
    }).createModule();

    // const LazyPath = std.Build.LazyPath;

    // const frontend_mod = b.createModule(.{
    //     // .root_source_file = b.path(frontend_path),
    //     // .root_source_file = std.Build.LazyPath.cwd_relative(frontend_path),
    //     // .root_source_file = LazyPath.cwd_relative(frontend_path),
    // });

    const frontend_mod = b.createModule(.{
        .root_source_file = .{ .cwd_relative = frontend_path },
    });

    const libquark_mod = b.addModule("libquark", .{
        .root_source_file = b.path("src/root.zig"),
    });
    libquark_mod.addImport("webview", webview);
    libquark_mod.addImport("frontend", frontend_mod);

    const libquark = b.addStaticLibrary(.{
        .name = "quark",
        .root_source_file = b.path("src/root.zig"),
        .optimize = optimize,
        .target = target,
    });

    libquark.addIncludePath(lib_webview.path("core/include/webview/"));
    libquark.root_module.addCMacro("WEBVIEW_STATIC", "1");
    libquark.linkLibCpp();
    libquark.root_module.addImport("frontend", frontend_mod);
    libquark.root_module.addImport("webview", webview);

    switch (@import("builtin").os.tag) {
        .macos => {
            libquark.addCSourceFile(.{ .file = lib_webview.path("core/src/webview.cc"), .flags = &.{"-std=c++11"} });
            libquark.linkFramework("WebKit");
        },
        .freebsd => {
            libquark.addCSourceFile(.{ .file = lib_webview.path("core/src/webview.cc"), .flags = &.{"-std=c++11"} });
            libquark.addIncludePath(.{ .cwd_relative = "/usr/local/include/cairo/" });
            libquark.addIncludePath(.{ .cwd_relative = "/usr/local/include/gtk-3.0/" });
            libquark.addIncludePath(.{ .cwd_relative = "/usr/local/include/glib-2.0/" });
            libquark.addIncludePath(.{ .cwd_relative = "/usr/local/lib/glib-2.0/include/" });
            libquark.addIncludePath(.{ .cwd_relative = "/usr/local/include/webkitgtk-4.1/" });
            libquark.addIncludePath(.{ .cwd_relative = "/usr/local/include/pango-1.0/" });
            libquark.addIncludePath(.{ .cwd_relative = "/usr/local/include/harfbuzz/" });
            libquark.addIncludePath(.{ .cwd_relative = "/usr/local/include/gdk-pixbuf-2.0/" });
            libquark.addIncludePath(.{ .cwd_relative = "/usr/local/include/atk-1.0/" });
            libquark.addIncludePath(.{ .cwd_relative = "/usr/local/include/libsoup-3.0/" });
            libquark.linkSystemLibrary("gtk-3");
            libquark.linkSystemLibrary("webkit2gtk-4.1");
        },
        .linux => {
            libquark.addCSourceFile(.{ .file = lib_webview.path("core/src/webview.cc"), .flags = &.{"-std=c++11"} });
            libquark.linkSystemLibrary("gtk+-3.0");
            libquark.linkSystemLibrary("webkit2gtk-4.1");
        },
        else => {
            @compileError("Unsupported operating system for libquark.");
        },
    }

    b.installArtifact(libquark);
}

fn generate_frontend(b: *std.Build) ![]const u8 { // move this to it's own lib?
    const gpa = b.allocator;

    var buf = std.ArrayList(u8).init(gpa);
    defer buf.deinit();

    const writer = buf.writer();

    try writer.writeAll(
        \\/// This file is auto-generated by Quark.
        \\/// It embeds static frontend assets (HTML, CSS, JS, etc) directly into the Zig binary
        \\/// for use at runtime without external dependencies. Do not edit this file.
        \\
        \\const std = @import("std");
        \\
        \\pub const File = struct {
        \\    name: []const u8,
        \\    data: []const u8,
        \\};
        \\
        \\pub const files = [_]File{
        \\
    );
    try collectFiles(gpa, writer, "src/frontend", "");

    try writer.writeAll("};\n");

    try writer.writeAll(
        \\
        \\pub fn get(name: []const u8) ?[]const u8 {
        \\    for (files) |file| {
        \\        if (std.mem.eql(u8, file.name, name)) return file.data;
        \\    }
        \\    return null;
        \\}
    );

    const filename = "binder.zig";
    const full_path = try std.fs.path.join(b.allocator, &.{ "src", filename });
    try std.fs.cwd().makePath(std.fs.path.dirname(full_path).?);

    const file = try std.fs.cwd().createFile(full_path, .{ .truncate = true });
    defer file.close();

    try file.writeAll(buf.items);

    return full_path;
}

fn collectFiles(gpa: std.mem.Allocator, writer: anytype, base_path: []const u8, relative_path: []const u8) !void {
    const fs = std.fs;

    const current_path = if (relative_path.len == 0)
        base_path
    else
        try std.fs.path.join(gpa, &.{ base_path, relative_path });
    defer if (relative_path.len > 0) gpa.free(current_path);

    var dir = fs.cwd().openDir(current_path, .{ .iterate = true }) catch |err| switch (err) {
        error.FileNotFound => {
            std.log.warn("Frontend directory '{s}' not found, skipping...", .{current_path});
            return;
        },
        else => return err,
    };
    defer dir.close();

    var it = dir.iterate();
    while (try it.next()) |entry| {
        const entry_relative_path = if (relative_path.len == 0)
            entry.name
        else
            try std.fs.path.join(gpa, &.{ relative_path, entry.name });
        defer if (relative_path.len > 0) gpa.free(entry_relative_path);

        switch (entry.kind) {
            .file => {
                try writer.print(
                    \\    .{{ .name = "{s}", .data = @embedFile("frontend/{s}") }},
                    \\
                , .{ entry_relative_path, entry_relative_path });
            },
            .directory => {
                try collectFiles(gpa, writer, base_path, entry_relative_path);
            },
            else => continue,
        }
    }
}
